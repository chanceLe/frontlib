# js 基础

---

### 作用域

1. 作用域 :可访问变量的合集。
   在 JavaScript 中, 作用域为可访问变量，对象，函数的集合。

   **作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性**。

   作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。

   ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。ES6 的到来，为我们提供了**块级作用域**,可通过新增命令 `let`和 `const`来体现。

2. 分类

- 全局作用域: 在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域:

  - 最外层函数和在最外层函数外面定义的变量拥有全局作用域
  - 所有末定义直接赋值的变量自动声明为拥有全局作用域
  - 所有 window 对象的属性拥有全局作用域
  - 如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样就会 污染全局命名空间, 容易引起命名冲突。

- 函数作用域: 是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部。

- 作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行。

  - 值得注意的是：块语句（大括号{}中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们**不会创建一个新的作用域**。在块语句中定义的变量将保留在它们已经存在的作用域中。

- 块级作用域: 块级作用域可通过新增命令 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问。块级作用域在如下情况被创建：

  - 在一个函数内部
  - 在一个代码块（由一对花括号包裹）内部

  块级作用域有以下特点:

  - 声明变量不会提升到代码块顶部
  - 禁止重复声明
  - 循环中的绑定块作用域的妙用

---

### 作用域链

1. **自由变量**: 当前作用域没有定义的变量,称为自由变量。
2. 自由变量的值在当前作用域没有找到,会一层一层向上寻找,直到找到顶层全局作用域还没找到,就宣布放弃。这种变量查找的层级关系,就是作用域链。
3. 自由变量取值, 要到创建函数的那个作用域中取，无论函数将在哪里调用 ---这就是所谓的 **静态作用域**。

---

### 执行上下文

1. 当代码运行时，会产生一个对应的执行环境,在这个环境中,所有变量会被事先提出来(变量提升),有的直接赋值,有的为默认值 undefined, 代码从上往下开始执行，就叫做执行上下文。
2. js 中,运行环境分为三种:

   - 全局环境：代码首先进入的环境
   - 函数环境：函数被调用时执行的环境
   - eval 函数(不常用)

3. 执行上下文特点:
   - 单线程,在主进程上运行
   - 同步执行，从上往下按顺序执行
   - 全局上下文只有一个，浏览器关闭时会被弹出栈
   - 函数的执行上下文没有数目限制
   - 函数每被调用一次，都会产生一个新的执行上下文环境
4. 执行上下文栈
   执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态的执行上下文环境只有一个。

其实这是一个压栈出栈的过程——执行上下文栈。

5. 执行上下文生命周期

   执行上下文共分 3 个阶段，分别是：

   1. 创建阶段
      - 生成变量对象
      - 建立作用域链
      - 确定 this 指向
   2. 执行阶段
      - 变量赋值
      - 函数引用
      - 执行其他代码
   3. 销毁阶段
      - 执行完毕出栈，等待回收被销毁

---

### JS 执行过程

JavaScript 是解释型语言，也就是说我们的 js 代码会通过一个解释器来进行解释执行，这个解释器我们称为 js 引擎，因为我们的浏览器也能执行 js，所以浏览器里面也有 js 引擎，不同的浏览器有不同的 js 引擎，比如 chrome 的 V8，safari 的 webkit，IE 浏览器的 Trident 等。

JS 引擎的执行,有三个步骤:

1. **分词/词法分析** ：将由字符串组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）（空格是否被当做此法单元，取决于空格在这门语言中是否具有意义）
2. **语法分析**：将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树（抽象语法树，Abstract Syntax Tree, AST）
3. **代码生成**：将 AST 转换成可执行代码的过程
4. **预编译**
   - 全局
     - 创建 Global Object 对象（GO）
     - 查找变量声明
       - 如果 GO 上还没有该属性，则添加该属性，值为 undefined
       - 如果 GO 上已经有该属性，则不做任何处理
     - 查找函数声明（eg. function foo () {}）
       - 如果 GO 上还没有 foo 属性，则把函数赋值给 foo 属性 - 如果 GO 上已经存在 foo 属性，则直接覆盖
   - 函数
     - 函数运行前的一瞬间，生成 Activation Object（活动对象），简称 AO
     - 分析参数
       - 把声明的参数形成 AO 的属性，值全为 undefined - 接收实参，形成 AO 相应属性的值
     - 分析变量声明
       - 如果 AO 上还没有该属性，则添加该属性，值为 undefined
       - 如果 AO 上已经有该属性，则不做任何处理
     - 分析函数声明（eg. function foo () {}）
       - 如果 AO 上还没有 foo 属性，则把函数赋值给 foo 属性
       - 如果 AO 上已经存在 foo 属性，则直接覆盖
5. **解释并执行代码**

---

### 数据类型

最新的 ECMAScript 标准定义了 8 种数据类型:

- 7 种原始类型
  - Boolean
  - Null
  - Undefined
  - Number
  - BigInt
  - String
  - Symbol
- 引用类型
  - Object

原始值

- 布尔类型：表示一个逻辑实体,可以有两个值:`true`和`false`
- Null 类型：只有一个值 null
- Undefined 类型：没有被赋值的变量会有个默认值`undefined`
- 数字类型：根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(253 -1) 到 253 -1）。它并没有为整数给出一种特定的类型。除了能够表示浮点数外，还有一些带符号的值：+Infinity，-Infinity 和 NaN (非数值，Not-a-Number)。

  要检查值是否大于或小于 +/-Infinity，你可以使用常量 Number.MAX_VALUE 和 Number.MIN_VALUE。另外在 ECMAScript 6 中，你也可以通过 Number.isSafeInteger() 方法还有 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 来检查值是否在双精度浮点数的取值范围内。 超出这个范围，JavaScript 中的数字不再安全了，也就是只有 second mathematical interger 可以在 JavaScript 数字类型中正确表现。

  ```js
  42 / +0; // Infinity
  42 / -0; // -Infinity
  ```

- 字符串类型: 它是一组 16 位的无符号整数值的“元素”。在字符串中的每个元素占据了字符串的位置。第一个元素的索引为 0，下一个是索引 1，依此类推。字符串的长度是它的元素的数量。

  不同于类 C 语言，JavaScript 字符串是不可更改的。这意味着字符串一旦被创建，就不能被修改。但是，可以基于对原始字符串的操作来创建新的字符串。例如：

  - 获取一个字符串的子串可通过选择个别字母或者使用 String.substr()
  - 两个字符串的连接使用连接操作符 (+) 或者 String.concat()

- Symbol 符号类型：符号(Symbols)是 ECMAScript 第 6 版新定义的。符号类型是唯一的并且是不可修改的, 并且也可以用来作为 Object 的 key 的值.
- 对象：在计算机科学中, 对象是指内存中的可以被**标识符**引用的一块区域.

  ECMAScript 定义的对象中有两种属性：数据属性和访问器属性。

  1.  数据属性：数据属性是键值对，并且每个数据属性拥有下列特性:

  | 特性             | 数据类型             | 描述                                                                                               | 默认值    |
  | ---------------- | -------------------- | -------------------------------------------------------------------------------------------------- | --------- |
  | [[Value]]        | 任何 Javascript 类型 | 包含这个属性的数据值。                                                                             | undefined |
  | [[Writable]]     | Boolean              | 如果该值为 false，则该属性的 [[Value]] 特性 不能被改变。                                           | false     |
  | [[Enumerable]]   | Boolean              | 如果该值为 true，则该属性可以用 for...in 循环来枚举。                                              | false     |
  | [[Configurable]] | Boolean              | 如果该值为 false，则该属性不能被删除，并且 除了 [[Value]] 和 [[Writable]] 以外的特性都不能被改变。 | false     |

  2.  访问器属性：访问器属性有一个或两个访问器函数 (get 和 set) 来存取数值，并且有以下特性:

  | 特性             | 类型                   | 描述                                                                     | 默认值    |
  | ---------------- | ---------------------- | ------------------------------------------------------------------------ | --------- |
  | [[Get]]          | 函数对象或者 undefined | 该函数使用一个空的参数列表，能够在有权访问的情况下读取属性值。另见 get。 | undefined |
  | [[Set]]          | 函数对象或者 undefined | 该函数有一个参数，用来写入属性值，另见 set。                             | undefined |
  | [[Enumerable]]   | Boolean                | 如果该值为 true，则该属性可以用 for...in 循环来枚举。                    | false     |
  | [[Configurable]] | Boolean                | 如果该值为 false，则该属性不能被删除，并且不能被转变成一个数据属性。     | false     |

  > 注意：这些特性只有 JavaScript 引擎才用到，因此你不能直接访问它们。所以特性被放在两对方括号中，而不是一对。

---

### 类型判断

1. `typeof` 操作符
2. `constructor` 返回构造方法
   ```js
   let a = 1;
   a.constructor === Number; //true
   ```
3. `toString` : 其他类型转成 string 的方法
   - 支持 number、boolean、string、object, symbol
   - 不支持 null 、undefined
4. `toLocaleString()` :把数组转成本地字符串
   ```js
   [1, 2, 3].toLocaleString(); //"1,2,3"
   ```
5. 检测数组类型的方法
   - `instanceof` 操作符
   - 对象的`constructor`属性
   - `Array.isArray()`
6. `Object.is(a,b)` 判断对象是否是同一个

---

### 类型转换

JS 中 `typeof`可以用来检测数据类型

```js
typeof mix; //mix可以是任何数据类型
```

typeof 的返回值有 7 种： `number`、`string`、`boolean`、`object`、`symbol`、`function`和`undefined`

1. 显式类型转换：通过使用 JavaScript 函数
2. 隐式类型转换：通过 JavaScript 自身自动转换,只要是涉及到不同数据类型需要计算的时候都会触发隐式类型转换，主要有三种转换方式:

   - 将值转为原始值，toPrimitive(input,preferedType?)

   是 js 的一个内部的算法，是内部执行的时候遵循的一套规则, input 是输入的值，preferedType 是期望转换的类型，他可以是字符串，也可以是数字。
   如果转换的类型是 number，会执行以下步骤： 1. 如果 input 是原始值，直接返回这个值； 2. 否则，如果 input 是对象，调用 input.valueOf()，如果结果是原始值，返回结果； 3. 否则，调用 input.toString()。如果结果是原始值，返回结果； 4. 否则，抛出错误。

   如果转换的类型是 String，2 和 3 会交换执行，即先执行 toString()方法。你也可以省略 preferedType，此时，日期会被认为是字符串，而其他的值会被当做 Number。

   - 将值转为数字，toNumber()
   - 将值转为字符串，toString()

---

### 闭包

浏览器加载页面会把代码放到栈内存中执行（ECStack）,函数进栈执行会产生一个私有的上下文（EC），
此上下文能保护里面的私有变量（AO）不受外界的干扰,并且如果当前上下文中的某些内容，被上下文以外的内容所占用
当前上下文是不会出栈释放的,形成不被销毁的栈内存，这样可以保存住里面的变量和变量值。所以我认为闭包是一种保存和保护
内部私有变量的机制...在真实的项目中,闭包应用的场景还是挺多的，例如

1. 我会基于闭包把自己编写的模块内容包起来，这样自己编写的代码是私有的，防止和全局变量或者别人的代码冲突，这一点利用的是闭包的保护机制。

2. 在没用 let 之前，循环处理事假绑定，在事件触发的需要用到索引值得时候，我们基于闭包把每一轮循环的索引值保存起来，这样来实现我们的需求。只不过现在都是基于 let 来做，因为 let 会产生块级作用域来保存需要的内容(机制和闭包类似),但是不建议过多使用闭包,因为形成不被释放的上下文，是占用栈内存空间的，过多使用会导致页面渲染变慢,也就是说的内存泄漏,所以要合理应用闭包

3. 除了这些传统的业务开发中会应用闭包,在研究别人源码 和自己写一些插件的时候，往往会利用一些 js 高阶编程技巧来实现代码的管理和功能的开发，他们的底层机制其实就是闭包。例如:

   - 惰性函数
   - 柯里化函数
   - compose 函数

---

### 防抖和节流

---

### 原型和继承

---

### 事件循环

---

### 高级函数
